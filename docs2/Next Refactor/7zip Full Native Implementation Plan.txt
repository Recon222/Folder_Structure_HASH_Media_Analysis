7zip Native Implementation Plan

  Windows-Only, High-Performance Archive Solution

  Target Performance: 7-14x improvement (290 MB/s â†’ 2,000-4,000 MB/s)Platform: Windows only (no cross-platform
  concerns)Architecture: Replace existing ZIP system with native 7zip subprocess calls

  ---
  ðŸ“‹ Implementation Overview

  Core Strategy

  - Replace existing ZipUtility and BufferedZipOperations with native 7zip
  - Bundle 7za.exe with application for guaranteed availability
  - Optimize for Windows-specific performance characteristics
  - Maintain existing controller and thread architecture

  Performance Targets

  | Component            | Current  | Target      | Improvement |
  |----------------------|----------|-------------|-------------|
  | Small files (<1MB)   | 290 MB/s | 2,000+ MB/s | 7x          |
  | Large files (>100MB) | 290 MB/s | 4,000+ MB/s | 14x         |
  | Mixed workloads      | 290 MB/s | 2,500+ MB/s | 9x          |

  ---
  ðŸ“… Phase 1: Foundation Setup

  Week 1 - Core Infrastructure

  Step 1.1: Binary Integration

  Files to create:
  - core/native_7zip/binary_manager.py
  - core/native_7zip/__init__.py

  Implementation:
  # core/native_7zip/binary_manager.py
  class Native7ZipBinaryManager:
      """Manages 7za.exe binary for Windows"""

      def __init__(self):
          self.binary_path = self._get_bundled_binary_path()
          self.version_info = None
          self._validate_binary()

      def _get_bundled_binary_path(self) -> Path:
          """Get path to bundled 7za.exe"""
          # Bundle in /bin/7za.exe relative to main.py
          app_root = Path(__file__).parent.parent.parent
          return app_root / "bin" / "7za.exe"

      def is_available(self) -> bool:
          """Check if 7zip binary is available and functional"""
          return self.binary_path and self.binary_path.exists()

      def _validate_binary(self) -> bool:
          """Validate binary works by running version check"""
          if not self.is_available():
              return False

          try:
              result = subprocess.run(
                  [str(self.binary_path), "--version"],
                  capture_output=True,
                  timeout=5
              )
              self.version_info = result.stdout.decode()
              return result.returncode == 0
          except Exception:
              return False

  Step 1.2: Command Builder

  Files to create:
  - core/native_7zip/command_builder.py

  Implementation:
  # core/native_7zip/command_builder.py
  class ForensicCommandBuilder:
      """Builds optimized 7zip commands for Windows forensic workloads"""

      def __init__(self):
          self.cpu_count = os.cpu_count()
          self.optimal_threads = self._calculate_optimal_threads()

      def build_archive_command(self, source_path: Path, output_path: Path,
                              compression_level: str = "store") -> List[str]:
          """Build forensic-optimized archive command"""

          cmd = [
              str(binary_path),
              'a',                                    # Add to archive
              '-mx0',                                 # Store mode (no compression)
              f'-mmt{self.optimal_threads}',          # Optimal thread count
              '-mmemuse=p80',                         # Use 80% of system RAM
              '-y',                                   # Auto-confirm all prompts
              '-spf',                                 # Store full paths
              '-ms=off',                              # Non-solid archives
              '-bb1',                                 # Basic progress output
              f'-w{source_path.parent}',              # Set working directory
              str(output_path),                       # Output archive path
              f'{source_path}\\*'                     # Include all contents
          ]

          return cmd

      def _calculate_optimal_threads(self) -> int:
          """Calculate optimal thread count for Windows"""
          if self.cpu_count <= 4:
              return self.cpu_count
          elif self.cpu_count <= 16:
              return self.cpu_count
          else:
              return min(32, self.cpu_count)  # Cap at 32 threads

  Step 1.3: Download and Bundle Binary

  Tasks:
  1. Download 7za.exe from official 7-Zip website
  2. Create /bin/ directory in project root
  3. Add 7za.exe to /bin/7za.exe
  4. Update .gitignore if needed to include binary
  5. Verify binary works with test command

  Verification command:
  ./bin/7za.exe --version

  ---
  ðŸ“… Phase 2: Core Implementation

  Week 2 - Native Archive Creation

  Step 2.1: Native 7Zip Controller

  Files to create:
  - core/native_7zip/controller.py

  Implementation:
  # core/native_7zip/controller.py
  class Native7ZipController:
      """Main controller for native 7zip operations"""

      def __init__(self, progress_callback: Optional[Callable] = None):
          self.binary_manager = Native7ZipBinaryManager()
          self.command_builder = ForensicCommandBuilder()
          self.progress_callback = progress_callback
          self.performance_metrics = None
          self.cancelled = False

      def create_archive(self, source_path: Path, output_path: Path) -> Result[ArchiveOperationResult]:
          """Create archive using native 7zip with performance monitoring"""

          if not self.binary_manager.is_available():
              return Result.error(ArchiveError("7za.exe not available"))

          # Build command
          cmd = self.command_builder.build_archive_command(source_path, output_path)

          # Execute with monitoring
          return self._execute_with_monitoring(cmd, source_path, output_path)

      def _execute_with_monitoring(self, cmd: List[str], source_path: Path,
                                 output_path: Path) -> Result[ArchiveOperationResult]:
          """Execute 7zip command with real-time progress monitoring"""

          start_time = time.time()

          try:
              # Start process
              process = subprocess.Popen(
                  cmd,
                  stdout=subprocess.PIPE,
                  stderr=subprocess.PIPE,
                  universal_newlines=True,
                  cwd=source_path.parent
              )

              # Monitor progress
              self._monitor_progress(process)

              # Wait for completion
              returncode = process.wait()
              end_time = time.time()

              if returncode == 0:
                  # Success - create result
                  archive_size = output_path.stat().st_size if output_path.exists() else 0

                  result_data = ArchiveOperationResult.create_successful(
                      created_archives=[output_path],
                      compression_level="store",
                      metadata={
                          'duration': end_time - start_time,
                          'archive_size': archive_size,
                          'method': 'native_7zip'
                      }
                  )

                  return result_data
              else:
                  # Error - parse stderr
                  stderr_output = process.stderr.read() if process.stderr else "Unknown error"
                  return Result.error(ArchiveError(f"7zip failed: {stderr_output}"))

          except Exception as e:
              return Result.error(ArchiveError(f"Failed to execute 7zip: {e}"))

      def _monitor_progress(self, process: subprocess.Popen):
          """Monitor subprocess output for progress updates"""

          while True:
              if process.poll() is not None:
                  break

              if self.cancelled:
                  process.terminate()
                  break

              # Read progress output (7zip -bb1 provides basic progress)
              try:
                  line = process.stdout.readline()
                  if line:
                      self._parse_progress_line(line.strip())
              except:
                  pass

              time.sleep(0.1)  # Small delay to prevent excessive CPU usage

      def _parse_progress_line(self, line: str):
          """Parse 7zip progress output"""
          # 7zip progress format: "filename" or percentage updates
          if self.progress_callback:
              if "%" in line:
                  # Try to extract percentage
                  import re
                  match = re.search(r'(\d+)%', line)
                  if match:
                      percentage = int(match.group(1))
                      self.progress_callback(percentage, f"7zip: {line}")
              else:
                  # File name or status update
                  self.progress_callback(0, f"7zip: {line}")

      def cancel(self):
          """Cancel current operation"""
          self.cancelled = True

  Step 2.2: Replace ZipUtility Class

  Files to modify:
  - utils/zip_utils.py - Complete replacement

  Implementation:
  # utils/zip_utils.py - COMPLETE REPLACEMENT
  #!/usr/bin/env python3
  """
  Native 7zip utility for high-performance archive creation
  Windows-only implementation using bundled 7za.exe
  """

  from pathlib import Path
  from typing import List, Optional, Callable
  from dataclasses import dataclass
  import zipfile  # Keep for compression level constants

  from core.native_7zip.controller import Native7ZipController
  from core.result_types import Result, ArchiveOperationResult
  from core.logger import logger


  @dataclass
  class ZipSettings:
      """Settings for archive operations (now using 7zip)"""
      compression_level: str = "store"  # "store", "fast", "normal", "max"
      create_at_root: bool = True
      create_at_location: bool = False
      create_at_datetime: bool = False
      output_path: Optional[Path] = None


  class ZipUtility:
      """
      High-performance archive utility using native 7zip

      Replaces Python zipfile implementation with native 7za.exe
      for 7-14x performance improvement on Windows systems.
      """

      def __init__(self, progress_callback: Optional[Callable[[int, str], None]] = None):
          """Initialize with native 7zip controller"""
          self.progress_callback = progress_callback
          self.native_controller = Native7ZipController(progress_callback)
          self.cancelled = False

          # Verify 7zip availability
          if not self.native_controller.binary_manager.is_available():
              logger.error("7za.exe not found - archive operations will fail")

      def create_archive(self, source_path: Path, output_path: Path,
                        settings: Optional[ZipSettings] = None) -> bool:
          """
          Create archive using native 7zip

          Args:
              source_path: Directory to compress
              output_path: Where to save the archive
              settings: Archive settings

          Returns:
              True if successful
          """
          if settings is None:
              settings = ZipSettings()

          logger.info(f"Creating archive using native 7zip: {source_path} -> {output_path}")

          # Use native 7zip controller
          result = self.native_controller.create_archive(source_path, output_path)

          if result.success:
              logger.info(f"Archive created successfully: {output_path}")
              if self.progress_callback:
                  self.progress_callback(100, f"Archive complete: {output_path.name}")
              return True
          else:
              logger.error(f"Archive creation failed: {result.error}")
              if self.progress_callback:
                  self.progress_callback(0, f"Archive failed: {result.error}")
              return False

      def cancel(self):
          """Cancel current operation"""
          self.cancelled = True
          self.native_controller.cancel()

      # Keep existing multi-level archive method but use native 7zip
      def create_multi_level_archives(self, root_path: Path, settings: ZipSettings,
                                     form_data=None) -> List[Path]:
          """Create archives at multiple levels using native 7zip"""
          created_archives = []

          try:
              def create_descriptive_archive_name() -> str:
                  if form_data:
                      occurrence = form_data.occurrence_number or "Unknown"
                      business = form_data.business_name or ""
                      location = form_data.location_address or ""

                      name_parts = [occurrence]
                      if business:
                          name_parts.append(business)
                      if location:
                          name_parts.append(f"@ {location}")
                      name_parts.append("Video Recovery")

                      return " ".join(name_parts) + ".7z"  # Changed to .7z extension
                  else:
                      name = root_path.name.replace(' ', '_')
                      return f"{name}_Complete.7z"  # Changed to .7z extension

              # Create at root level
              if settings.create_at_root and root_path.exists():
                  output = settings.output_path or root_path.parent
                  archive_name = create_descriptive_archive_name()
                  archive_path = output / archive_name
                  if self.create_archive(root_path, archive_path, settings):
                      created_archives.append(archive_path)

              # Create at location level
              if settings.create_at_location:
                  for location_folder in root_path.iterdir():
                      if location_folder.is_dir() and not self.cancelled:
                          output = settings.output_path or location_folder.parent
                          archive_name = create_descriptive_archive_name()
                          archive_path = output / archive_name
                          if self.create_archive(location_folder, archive_path, settings):
                              created_archives.append(archive_path)

              # Create at datetime level
              if settings.create_at_datetime:
                  for location_folder in root_path.iterdir():
                      if location_folder.is_dir():
                          for datetime_folder in location_folder.iterdir():
                              if datetime_folder.is_dir() and not self.cancelled:
                                  output = settings.output_path or datetime_folder.parent
                                  archive_name = create_descriptive_archive_name()
                                  archive_path = output / archive_name
                                  if self.create_archive(datetime_folder, archive_path, settings):
                                      created_archives.append(archive_path)

          except Exception as e:
              logger.error(f"Error creating multi-level archives: {e}")
              if self.progress_callback:
                  self.progress_callback(0, f"Error: {str(e)}")

          return created_archives

  Step 2.3: Update Dependencies

  Files to modify:
  - requirements.txt - No changes needed (removing zipfile dependencies)
  - core/native_7zip/__init__.py - Create package init

  Implementation:
  # core/native_7zip/__init__.py
  """
  Native 7zip integration for high-performance archive operations
  Windows-only implementation using bundled 7za.exe
  """

  from .binary_manager import Native7ZipBinaryManager
  from .command_builder import ForensicCommandBuilder
  from .controller import Native7ZipController

  __all__ = ['Native7ZipBinaryManager', 'ForensicCommandBuilder', 'Native7ZipController']

  ---
  ðŸ“… Phase 3: Integration & Thread Safety

  Week 3 - Threading and UI Integration

  Step 3.1: Update ZipOperationThread

  Files to modify:
  - core/workers/zip_operations.py - Complete replacement

  Implementation:
  # core/workers/zip_operations.py - COMPLETE REPLACEMENT
  #!/usr/bin/env python3
  """
  Native 7zip operation thread for high-performance archive creation
  Windows-only implementation using bundled 7za.exe
  """

  from pathlib import Path
  from PySide6.QtCore import QThread, Signal
  from typing import Optional

  from core.native_7zip.controller import Native7ZipController
  from utils.zip_utils import ZipSettings
  from core.result_types import Result
  from core.logger import logger


  class ZipOperationThread(QThread):
      """Thread for native 7zip archive operations"""

      # Unified signals matching existing architecture
      result_ready = Signal(Result)
      progress_update = Signal(int, str)

      def __init__(self, occurrence_folder: Path, output_dir: Path,
                   settings: ZipSettings, form_data=None, parent=None):
          """Initialize native 7zip operation thread"""
          super().__init__(parent)
          self.occurrence_folder = occurrence_folder
          self.output_dir = output_dir
          self.settings = settings
          self.form_data = form_data
          self.cancelled = False

          # Initialize native controller with progress callback
          self.native_controller = Native7ZipController(self._handle_progress)

      def _handle_progress(self, percentage: int, message: str):
          """Handle progress updates from native controller"""
          self.progress_update.emit(percentage, message)

      def run(self):
          """Execute archive creation in separate thread"""
          try:
              logger.info(f"Starting native 7zip operation: {self.occurrence_folder}")

              # Create descriptive archive name
              archive_name = self._create_archive_name()
              archive_path = self.output_dir / archive_name

              # Emit starting progress
              self.progress_update.emit(0, f"Starting 7zip archive: {archive_name}")

              # Create archive using native 7zip
              result = self.native_controller.create_archive(
                  self.occurrence_folder,
                  archive_path
              )

              if result.success:
                  logger.info(f"Native 7zip operation completed: {archive_path}")
                  self.progress_update.emit(100, f"Archive complete: {archive_name}")
              else:
                  logger.error(f"Native 7zip operation failed: {result.error}")
                  self.progress_update.emit(0, f"Archive failed: {result.error}")

              # Emit final result
              self.result_ready.emit(result)

          except Exception as e:
              logger.error(f"Unexpected error in 7zip thread: {e}")
              error_result = Result.error(f"Thread error: {e}")
              self.result_ready.emit(error_result)

      def _create_archive_name(self) -> str:
          """Create descriptive archive name from form data"""
          if self.form_data:
              occurrence = self.form_data.occurrence_number or "Unknown"
              business = self.form_data.business_name or ""
              location = self.form_data.location_address or ""

              name_parts = [occurrence]
              if business:
                  name_parts.append(business)
              if location:
                  name_parts.append(f"@ {location}")
              name_parts.append("Video Recovery")

              return " ".join(name_parts) + ".7z"  # Native 7zip format
          else:
              name = self.occurrence_folder.name.replace(' ', '_')
              return f"{name}_Complete.7z"

      def cancel(self):
          """Cancel the current operation"""
          self.cancelled = True
          if hasattr(self, 'native_controller'):
              self.native_controller.cancel()

          # Request thread interruption
          self.requestInterruption()

      def is_cancelled(self) -> bool:
          """Check if operation is cancelled"""
          return self.cancelled or self.isInterruptionRequested()

  Step 3.2: Update ZipController Integration

  Files to modify:
  - controllers/zip_controller.py - Minimal changes needed

  Key changes:
  # In zip_controller.py - update compression level handling
  def get_zip_settings(self) -> ZipSettings:
      """Build ZipSettings object from current preferences"""
      settings = ZipSettings()

      # Convert old ZIP compression levels to 7zip modes
      compression_setting = self.settings.get('ZIP_COMPRESSION_LEVEL', zipfile.ZIP_STORED)
      if compression_setting == zipfile.ZIP_STORED:
          settings.compression_level = "store"  # No compression (fastest)
      elif compression_setting == zipfile.ZIP_DEFLATED:
          settings.compression_level = "fast"   # Light compression
      else:
          settings.compression_level = "store"  # Default to store mode

      # Rest remains the same...
      zip_level = self.settings.zip_level
      settings.create_at_root = (zip_level == 'root')
      settings.create_at_location = (zip_level == 'location')
      settings.create_at_datetime = (zip_level == 'datetime')

      return settings

  Step 3.3: Update UI References

  Files to modify:
  - Any UI dialogs that reference ZIP settings need to understand 7zip is now used
  - Update status messages to indicate "7zip" instead of "ZIP" where appropriate

  ---
  ðŸ“… Phase 4: Testing & Optimization

  Week 4 - Performance Validation and Polish

  Step 4.1: Performance Testing

  Files to create:
  - tests/test_native_7zip_performance.py

  Implementation:
  # tests/test_native_7zip_performance.py
  import time
  import tempfile
  from pathlib import Path
  import os

  from core.native_7zip.controller import Native7ZipController


  def create_test_files(test_dir: Path, file_count: int = 100, file_size_mb: int = 1):
      """Create test files for performance testing"""
      test_dir.mkdir(exist_ok=True)

      for i in range(file_count):
          file_path = test_dir / f"test_file_{i:03d}.dat"
          with open(file_path, 'wb') as f:
              f.write(os.urandom(file_size_mb * 1024 * 1024))


  def test_native_7zip_performance():
      """Test native 7zip performance vs baseline"""

      with tempfile.TemporaryDirectory() as temp_dir:
          temp_path = Path(temp_dir)
          test_data_dir = temp_path / "test_data"

          # Create test data
          print("Creating test data...")
          create_test_files(test_data_dir, file_count=50, file_size_mb=2)  # 100MB total

          # Test native 7zip
          controller = Native7ZipController()
          archive_path = temp_path / "test_archive.7z"

          print("Testing native 7zip performance...")
          start_time = time.time()

          result = controller.create_archive(test_data_dir, archive_path)

          end_time = time.time()
          duration = end_time - start_time

          if result.success:
              archive_size = archive_path.stat().st_size
              speed_mbps = (100 / duration)  # 100MB test data

              print(f"âœ… Native 7zip Performance Test")
              print(f"   Duration: {duration:.2f} seconds")
              print(f"   Speed: {speed_mbps:.1f} MB/s")
              print(f"   Archive size: {archive_size / (1024*1024):.1f} MB")
              print(f"   Compression ratio: {archive_size / (100*1024*1024):.2f}")

              # Performance validation
              if speed_mbps > 500:  # Expect at least 500 MB/s on modern systems
                  print("âœ… Performance target met!")
                  return True
              else:
                  print(f"âš ï¸ Performance below target (expected >500 MB/s)")
                  return False
          else:
              print(f"âŒ Test failed: {result.error}")
              return False


  if __name__ == "__main__":
      test_native_7zip_performance()

  Step 4.2: Error Handling Enhancement

  Files to modify:
  - core/native_7zip/controller.py - Add comprehensive error code handling

  Enhanced error handling:
  def _handle_7zip_exit_code(self, exit_code: int, stderr_output: str) -> str:
      """Convert 7zip exit codes to meaningful error messages"""

      error_codes = {
          0: "Success",
          1: "Warning (non-fatal errors)",
          2: "Fatal error",
          7: "Command line error",
          8: "Not enough memory for operation",
          255: "User stopped the process"
      }

      base_message = error_codes.get(exit_code, f"Unknown error (code {exit_code})")

      if stderr_output:
          return f"{base_message}: {stderr_output}"
      else:
          return base_message

  Step 4.3: Settings Integration

  Files to modify:
  - Add 7zip-specific settings if needed
  - Update UI to reflect that 7zip is being used instead of Python ZIP

  Step 4.4: Documentation Updates

  Files to modify:
  - CLAUDE.md - Update architecture section to reflect native 7zip usage
  - Add performance benchmarks
  - Document Windows-only requirement

  ---
  ðŸ“Š Validation Criteria

  Performance Benchmarks

  - Small files: >2,000 MB/s (100 files @ 1MB each)
  - Large files: >4,000 MB/s (5 files @ 100MB each)
  - Mixed workload: >2,500 MB/s (realistic forensic data mix)

  Functionality Tests

  - Forensic tab: Creates archives correctly
  - Batch processing: Handles multiple jobs sequentially
  - Multi-level archives: Root/location/datetime levels work
  - Progress reporting: Real-time updates during creation
  - Cancellation: Clean termination of operations
  - Error handling: Graceful failure with meaningful messages

  Integration Tests

  - Thread safety: No UI blocking during archive creation
  - Result objects: Proper success/error propagation
  - Settings: Compression and level settings respected
  - Form data: Descriptive archive naming works
  - File paths: Handles spaces and special characters

  ---
  ðŸš€ Expected Results

  Performance Improvements

  | Metric       | Before (Python ZIP) | After (Native 7zip) | Improvement       |
  |--------------|---------------------|---------------------|-------------------|
  | Small files  | 290 MB/s            | 2,000+ MB/s         | 7x faster         |
  | Large files  | 290 MB/s            | 4,000+ MB/s         | 14x faster        |
  | CPU usage    | High (Python)       | Optimized (native)  | Better efficiency |
  | Memory usage | High (buffering)    | Lower (streaming)   | Reduced footprint |

  Archive Quality

  - Bit-perfect: Store mode maintains forensic integrity
  - Fast access: Non-solid archives allow individual file extraction
  - Compatible: Standard 7z format readable by all 7zip tools
  - Reliable: Robust error handling and progress reporting

  Development Benefits

  - Simpler codebase: Remove complex Python buffering logic
  - Better performance: Native optimizations for Windows
  - Proven reliability: 7zip's battle-tested archive creation
  - Future-proof: Easy to add compression options later

  This implementation plan provides a clear, step-by-step approach to achieving 7-14x performance improvement while
  maintaining the forensic integrity and enterprise architecture your application requires.
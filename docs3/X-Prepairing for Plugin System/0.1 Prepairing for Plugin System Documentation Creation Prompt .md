# Ultimate Documentation Generation Prompt for Plugin Architecture Migration

## Instructions for Claude Code

You are tasked with creating comprehensive technical documentation for migrating the Folder Structure Utility application from a monolithic architecture to a plugin-based platform. This documentation will be the foundation for building a new v2 application with a minimal core and all features as plugins.

Please analyze the ENTIRE codebase deeply and create the following documentation in **multiple markdown files** organized by domain. Be exhaustively thorough - this documentation will be the sole reference for rebuilding the application.

---

## DOCUMENT 1: Core Architecture Extraction Guide
**Filename: `docs/v2/01-core-architecture-extraction.md`**

Create a complete architectural map of what MUST remain in the core application shell versus what becomes plugins. Include:

### Core Shell Components (What Stays)
- Document every class, function, and pattern from these files that must remain in core:
  - `core/services/service_registry.py` - Full ServiceRegistry implementation
  - `core/services/interfaces.py` - All interface definitions
  - `core/services/base_service.py` - BaseService class
  - `core/result_types.py` - Complete Result object system with all specialized types
  - `core/exceptions.py` - Full exception hierarchy with FSAError and all subclasses
  - `core/error_handler.py` - ErrorHandler with thread routing
  - `core/settings_manager.py` - SettingsManager singleton
  - `core/logger.py` - Logging configuration
  - `core/workers/base_worker.py` - BaseWorkerThread foundation
  - `ui/styles/carolina_blue.py` - Theme system
  - `ui/components/error_notification_system.py` - Error notification infrastructure

### Plugin Candidates (What Moves)
- Map each current tab to its plugin structure:
  - ForensicTab → forensic-plugin
  - BatchTab → batch-plugin  
  - HashingTab → hashing-plugin
- List all dependencies each plugin will need from core

### Shared Components Analysis
- Document which UI components should be in core vs plugin-specific:
  - `ui/components/form_panel.py` - Used by multiple tabs
  - `ui/components/files_panel.py` - Used by multiple tabs
  - `ui/components/log_console.py` - Used by multiple tabs
- Recommendation for each: core library, plugin copy, or shared module

---

## DOCUMENT 2: Service Layer API Reference
**Filename: `docs/v2/02-service-layer-api.md`**

Create complete API documentation for every service interface and implementation:

### Service Registry API
- Document the complete `ServiceRegistry` class from `core/services/service_registry.py`
- Include all methods: `register_singleton`, `register_factory`, `get_service`, `clear`
- Document the global registry pattern and helper functions
- Provide examples of service registration and retrieval

### Service Interfaces Documentation
For each interface in `core/services/interfaces.py`, document:
- **IService**: Base interface requirements
- **IPathService**: All path building and sanitization methods
- **IFileOperationService**: File operation methods and signatures
- **IReportService**: Report generation methods
- **IArchiveService**: Archive creation methods
- **IValidationService**: Validation methods
- **ISuccessMessageService**: Success message building methods

### Service Implementations
For each service implementation, document:
- Public methods and their signatures
- Required dependencies
- Configuration options
- Thread safety guarantees
- Error handling patterns
- Example usage from controllers

### Service Configuration
- Document `configure_services()` from `core/services/service_config.py`
- List all services and their registration order
- Document any circular dependency considerations
- Explain the ZipController dependency injection

---

## DOCUMENT 3: Result Objects & Error System Specification
**Filename: `docs/v2/03-result-error-system.md`**

### Result Object System
Document the complete Result system from `core/result_types.py`:

#### Base Result[T] Class
- All methods: `success()`, `error()`, `from_bool()`, `map()`, `and_then()`
- Generic type handling
- Metadata and warning support
- Chaining operations

#### Specialized Result Types
For each specialized type, document all fields and methods:
- **FileOperationResult**: files_processed, bytes_processed, performance_metrics
- **ValidationResult**: field_errors, has_errors, add_field_error()
- **BatchOperationResult**: success_rate, item_results
- **ReportGenerationResult**: output_path, report_type, page_count
- **HashOperationResult**: hash_values, verification_status
- **ArchiveOperationResult**: archive_path, compression_ratio

### Exception Hierarchy
Document the complete exception system from `core/exceptions.py`:

#### FSAError Base Class
- Thread context capture
- Severity levels (INFO, WARNING, ERROR, CRITICAL)
- User vs technical messages
- Recovery hints

#### Specialized Exceptions
Document each with examples:
- FileOperationError
- ValidationError
- ReportGenerationError
- HashVerificationError
- BatchProcessingError
- ThreadError
- ConfigurationError
- UIError
- TemplateValidationError

### Error Handler System
Document from `core/error_handler.py`:
- Thread-safe error routing
- Main thread signal emission
- UI callback registration
- Error statistics tracking
- Context preservation

---

## DOCUMENT 4: Threading & Worker Architecture
**Filename: `docs/v2/04-threading-architecture.md`**

### Base Worker Thread Pattern
Document `BaseWorkerThread` from `core/workers/base_worker.py`:
- Unified signal system: `result_ready`, `progress_update`
- Cancellation support
- Progress reporting pattern
- Error handling in threads

### Worker Thread Implementations
For each worker, document:
- **FileOperationThread**: File copying with buffering
- **FolderStructureThread**: Directory creation
- **BatchProcessorThread**: Sequential job processing
- **ZipOperationThread**: Archive creation
- **SingleHashWorker**: Hash calculation
- **VerificationWorker**: Hash verification

### Thread Communication Patterns
- Signal/slot connections
- Progress reporting (percentage, message)
- Result propagation
- Cancellation handling
- Parent/child thread relationships

---

## DOCUMENT 5: Plugin System Design Specification
**Filename: `docs/v2/05-plugin-system-design.md`**

### Plugin Interface Contract
Design and document the plugin interface:

```python
class IPlugin:
    """Base plugin interface"""
    @property
    def metadata(self) -> PluginMetadata
    def initialize(self, services: ServiceRegistry, settings: SettingsManager) -> Result[None]
    def create_widget(self) -> Optional[QWidget]
    def get_menu_actions(self) -> List[QAction]
    def get_toolbar_actions(self) -> List[QAction]
    def get_settings_widget(self) -> Optional[QWidget]
    def cleanup(self) -> Result[None]
```

### Plugin Metadata Structure
```python
@dataclass
class PluginMetadata:
    id: str
    name: str
    version: str
    author: str
    description: str
    category: str
    dependencies: Dict[str, str]
    permissions: List[str]
    entry_point: str
```

### Plugin Lifecycle
1. Discovery phase
2. Validation phase
3. Loading phase
4. Initialization phase
5. Runtime phase
6. Cleanup phase

### Plugin Communication
- Service access patterns
- Signal emission
- Settings storage
- Resource management

---

## DOCUMENT 6: Controller Layer Patterns
**Filename: `docs/v2/06-controller-patterns.md`**

### Base Controller Pattern
Document `BaseController` from `controllers/base_controller.py`:
- Service injection via `_get_service()`
- Error handling via `_handle_error()`
- Logging via `_log_operation()`

### Controller Implementations
Document each controller's:
- **WorkflowController**: Orchestrates file operations
  - `process_forensic_workflow()` method
  - `process_batch_workflow()` method
  - Service dependencies
- **ReportController**: Manages report generation
  - `generate_all_reports()` method
  - Report type handling
- **HashController**: Hash operations
  - Single file hashing
  - Verification operations
- **ZipController**: Archive management
  - Session state management
  - Settings integration

---

## DOCUMENT 7: Migration Dependencies Map
**Filename: `docs/v2/07-dependency-map.md`**

Create a comprehensive dependency map showing:

### Import Analysis
For each major component, list:
- Direct imports (what it imports)
- Reverse dependencies (what imports it)
- Circular dependency risks
- Migration order recommendations

### Critical Paths
Identify and document:
- Core dependencies that everything needs
- Optional dependencies that could be lazy-loaded
- Platform-specific dependencies
- Third-party library dependencies

### Migration Order
Recommend the order for migrating components:
1. Core infrastructure (must be first)
2. Service layer
3. Worker threads
4. Controllers
5. UI components
6. Individual tabs as plugins

---

## DOCUMENT 8: Settings & Configuration Architecture
**Filename: `docs/v2/08-settings-configuration.md`**

### Settings Manager System
Document from `core/settings_manager.py`:
- Singleton pattern implementation
- QSettings integration
- Key naming conventions (canonical keys)
- Type conversion handling
- Default values system

### Settings Categories
Document all settings by category:
- Forensic settings
- Performance settings
- Archive settings
- User settings
- Report settings
- UI settings
- Debug settings
- Path settings

### Plugin Settings Extension
Design how plugins will extend settings:
- Namespaced keys for plugins
- Dynamic settings registration
- Settings UI generation
- Migration and versioning

---

## DOCUMENT 9: UI Component Library
**Filename: `docs/v2/09-ui-components.md`**

### Reusable Components
For each component in `ui/components/`, document:
- **FormPanel**: Form data binding pattern
- **FilesPanel**: File/folder management
- **LogConsole**: Message logging
- **BatchQueueWidget**: Queue visualization
- **TemplateSelector**: Template selection
- **ElidedLabel**: Text truncation
- **PathLabel**: Path display

### Component Patterns
- Data binding via lambdas
- Signal emission patterns
- Parent/child relationships
- Style application

### Dialog System
Document all dialogs in `ui/dialogs/`:
- Modal vs non-modal patterns
- Settings persistence
- Validation patterns
- Result handling

---

## DOCUMENT 10: Plugin Development Guide
**Filename: `docs/v2/10-plugin-development-guide.md`**

### Plugin Structure Template
```
my-plugin/
├── plugin.json
├── __init__.py
├── plugin.py
├── ui/
│   └── tab_widget.py
├── services/
│   └── plugin_service.py
├── workers/
│   └── plugin_worker.py
└── resources/
    └── icons/
```

### Required Implementations
- Entry point class
- Widget creation
- Service registration
- Signal connections
- Settings integration

### Best Practices
- Error handling patterns
- Performance considerations
- Resource management
- Testing strategies

---

## DOCUMENT 11: Testing Architecture
**Filename: `docs/v2/11-testing-architecture.md`**

### Testing Patterns
Document from existing tests:
- Unit test patterns
- Integration test patterns
- Worker thread testing
- UI component testing
- Service mocking

### Test Infrastructure
- Test fixtures
- Mock objects
- Test data generators
- Performance benchmarks

### Plugin Testing
- Plugin validation tests
- Integration tests
- Performance tests
- Security tests

---

## DOCUMENT 12: Performance & Optimization Guide
**Filename: `docs/v2/12-performance-optimization.md`**

### Current Performance Characteristics
Document from `core/buffered_file_ops.py`:
- Adaptive buffer sizing
- File size categories
- Performance metrics collection
- Progress throttling

### 7-Zip Integration
Document from `core/native_7zip/`:
- Binary management
- Command building
- Performance characteristics
- Fallback mechanisms

### Threading Optimization
- Thread pool considerations
- Cancellation performance
- Progress update throttling
- Memory management

---

## ADDITIONAL REQUIREMENTS

### Code Analysis Depth
- Include **EVERY** public method signature
- Document **ALL** signal definitions
- Map **EVERY** import relationship
- List **ALL** configuration keys
- Document **EVERY** error code

### Documentation Style
- Use clear hierarchical headings
- Include code examples for every pattern
- Provide migration notes for each component
- Add decision rationale where architectural choices were made
- Include performance implications

### Special Attention Areas
1. **Service Registry**: This is the heart of the plugin system - document EVERYTHING
2. **Result Objects**: Critical for plugin communication - be exhaustive
3. **Worker Threads**: Complex threading patterns - include sequence diagrams
4. **Signal/Slot Connections**: Map every connection pattern
5. **Settings System**: Plugins will extend this - document extension points

### Output Format
- Create a separate markdown file for each document
- Use mermaid diagrams for architecture visualization
- Include code snippets with syntax highlighting
- Add tables for API references
- Create decision matrices where appropriate

---

## VERIFICATION CHECKLIST

After creating all documentation, verify:
- [ ] Every file in `core/` has been documented
- [ ] Every controller has complete API documentation
- [ ] Every service interface and implementation is covered
- [ ] All worker threads are documented with their signals
- [ ] Plugin interface is completely specified
- [ ] Migration path is clear for each component
- [ ] Dependencies are fully mapped
- [ ] Testing patterns are documented
- [ ] Performance considerations are noted
- [ ] No circular dependencies in migration plan

---

## FINAL NOTE

This documentation will be the **sole reference** for building v2. Be exhaustive. If something isn't documented here, it won't exist in v2. When in doubt, include more detail rather than less. The goal is that someone could rebuild the entire application using only this documentation, without ever looking at the original code.

Pay special attention to:
- The "Nuclear Migration" to Result objects - this pattern must be preserved
- The service-oriented architecture - this is the foundation for plugins
- The thread safety patterns - critical for stability
- The signal/slot communication - enables loose coupling

Remember: This documentation is the blueprint for transforming a monolithic application into an extensible platform. Make it extraordinary.